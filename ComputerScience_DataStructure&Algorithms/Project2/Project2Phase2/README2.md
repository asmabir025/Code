After recursively solving the same problem, phase 2 has turned out easier, especially given the algorithm. However, I slightly changed the algorithm. Instead of using stack in the find_battlefield_paths() method, I created a new method solve_paths and called the method in the find_battlefield_paths() method. At the beginning of the find_battlefield_paths() method, I first checked whether we have valid start or end points. If not, then we print the message of no path and return. In terms of algorithm change, instead of marking the path both in if and else parts, my code to mark is outside if-else statements (actually before them) of the solved_paths method(), which I think is more efficient and works perfectly fine. That is because I am checking the validity of a possible path point before going there. I do not need to worry about the starting point (starting_row, starting_row) in the solved_paths method() because I only use this method inside the find_battlefield_paths() method after knowing that the starting point is valid. 

I save the coordinates of the track in the attribute, path. However, path contains points from unsuccessful track(s) too, if there is any. In order to get rid of the unsuccessful part, I used the idea of branching. When a branch gets unsuccessful to reach the exit, the code returns to the root and starts making another branch. Now, the last point of the unsuccessful banch cannot be a neighbor of the first outreach point of the next branch because our drone only moves in four perpendicular directions. That is why I try to catch the point in the list of path, which is not a neighbor of its previous point. After catching it, the code goes backward in the list to catch a point, which is a neighbor of the caught point, and therefore, the root. Then the code removes the coordinates between, of the unsuccessful branch. The single_path() method does this whole job. That is how my code is able to print out a complete, only-successful track. 

I only print out the path when the attribute found_path is True. Also, the helper function neighbors() makes finding the job easier to find neighbors in solve_paths() and single_path() methods.

I created battlefield4.dat in a way that if the exit row is more than one row below or above the starting row, there will be no path found. I first created a 6*12 matrix and copied and pasted to make 12*12. Although, I had to change row 7 to get the aspired battlefield. I do not think showing one output gives any justice to show why it is interesting. 